C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE INV_MPU_DMP_MOTION_DRIVER
OBJECT MODULE PLACED IN .\Objects\inv_mpu_dmp_motion_driver.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE DMP\inv_mpu_dmp_motion_driver.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\
                    -DMP) DEBUG OBJECTEXTEND PRINT(.\Listings\inv_mpu_dmp_motion_driver.lst) TABS(2) OBJECT(.\Objects\inv_mpu_dmp_motion_driv
                    -er.obj)

line level    source

   1          /*
   2           $License:
   3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
   4              See included License.txt for License information.
   5           $
   6           */
   7          /**
   8           *  @addtogroup  DRIVERS Sensor Driver Layer
   9           *  @brief       Hardware drivers to communicate with sensors via I2C.
  10           *
  11           *  @{
  12           *      @file       inv_mpu_dmp_motion_driver.c
  13           *      @brief      DMP image and interface functions.
  14           *      @details    All functions are preceded by the dmp_ prefix to
  15           *                  differentiate among MPL and general driver function calls.
  16           */
  17          #include <stdio.h>
  18          #include <stdint.h>
*** WARNING C318 IN LINE 18 OF DMP\inv_mpu_dmp_motion_driver.c: can't open file 'stdint.h'
  19          #include <stdlib.h>
  20          #include <string.h>
  21          #include <math.h>
  22          #include "inv_mpu.h"
  23          #include "inv_mpu_dmp_motion_driver.h"
  24          #include "dmpKey.h"
  25          #include "dmpmap.h"
  26          #include "uart.h"
  27          #include "delay.h"
  28          
  29          //定义目标板采用MSP430
  30          #define  MOTION_DRIVER_TARGET_MSP430
  31          
  32          /* The following functions must be defined for this platform:
  33           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
  34           *      unsigned char length, unsigned char const *data)
  35           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
  36           *      unsigned char length, unsigned char *data)
  37           * delay_ms(unsigned long num_ms)
  38           * get_ms(unsigned long *count)
  39           */
  40          #if defined MOTION_DRIVER_TARGET_MSP430
  41          //#include "msp430.h"
  42          //#include "msp430_clock.h"
  43          #define delay_ms    delay_ms
  44          #define get_ms      mget_ms
  45          #define log_i     printf
  46          #define log_e     printf
  47          
  48          #elif defined EMPL_TARGET_MSP430
              #include "msp430.h"
              #include "msp430_clock.h"
              #include "log.h"
              #define delay_ms    msp430_delay_ms
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 2   

              #define get_ms      msp430_get_clock_ms
              #define log_i       MPL_LOGI
              #define log_e       MPL_LOGE
              
              #elif defined EMPL_TARGET_UC3L0
              /* Instead of using the standard TWI driver from the ASF library, we're using
               * a TWI driver that follows the slave address + register address convention.
               */
              #include "delay.h"
              #include "sysclk.h"
              #include "log.h"
              #include "uc3l0_clock.h"
              /* delay_ms is a function already defined in ASF. */
              #define get_ms  uc3l0_get_clock_ms
              #define log_i       MPL_LOGI
              #define log_e       MPL_LOGE
              
              #else
              #error  Gyro driver is missing the system layer implementations.
              #endif
  73          
  74          /* These defines are copied from dmpDefaultMPU6050.c in the general MPL
  75           * releases. These defines may change for each DMP image, so be sure to modify
  76           * these values when switching to a new image.
  77           */
  78          #define CFG_LP_QUAT             (2712)
  79          #define END_ORIENT_TEMP         (1866)
  80          #define CFG_27                  (2742)
  81          #define CFG_20                  (2224)
  82          #define CFG_23                  (2745)
  83          #define CFG_FIFO_ON_EVENT       (2690)
  84          #define END_PREDICTION_UPDATE   (1761)
  85          #define CGNOTICE_INTR           (2620)
  86          #define X_GRT_Y_TMP             (1358)
  87          #define CFG_DR_INT              (1029)
  88          #define CFG_AUTH                (1035)
  89          #define UPDATE_PROP_ROT         (1835)
  90          #define END_COMPARE_Y_X_TMP2    (1455)
  91          #define SKIP_X_GRT_Y_TMP        (1359)
  92          #define SKIP_END_COMPARE        (1435)
  93          #define FCFG_3                  (1088)
  94          #define FCFG_2                  (1066)
  95          #define FCFG_1                  (1062)
  96          #define END_COMPARE_Y_X_TMP3    (1434)
  97          #define FCFG_7                  (1073)
  98          #define FCFG_6                  (1106)
  99          #define FLAT_STATE_END          (1713)
 100          #define SWING_END_4             (1616)
 101          #define SWING_END_2             (1565)
 102          #define SWING_END_3             (1587)
 103          #define SWING_END_1             (1550)
 104          #define CFG_8                   (2718)
 105          #define CFG_15                  (2727)
 106          #define CFG_16                  (2746)
 107          #define CFG_EXT_GYRO_BIAS       (1189)
 108          #define END_COMPARE_Y_X_TMP     (1407)
 109          #define DO_NOT_UPDATE_PROP_ROT  (1839)
 110          #define CFG_7                   (1205)
 111          #define FLAT_STATE_END_TEMP     (1683)
 112          #define END_COMPARE_Y_X         (1484)
 113          #define SKIP_SWING_END_1        (1551)
 114          #define SKIP_SWING_END_3        (1588)
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 3   

 115          #define SKIP_SWING_END_2        (1566)
 116          #define TILTG75_START           (1672)
 117          #define CFG_6                   (2753)
 118          #define TILTL75_END             (1669)
 119          #define END_ORIENT              (1884)
 120          #define CFG_FLICK_IN            (2573)
 121          #define TILTL75_START           (1643)
 122          #define CFG_MOTION_BIAS         (1208)
 123          #define X_GRT_Y                 (1408)
 124          #define TEMPLABEL               (2324)
 125          #define CFG_ANDROID_ORIENT_INT  (1853)
 126          #define CFG_GYRO_RAW_DATA       (2722)
 127          #define X_GRT_Y_TMP2            (1379)
 128          
 129          #define D_0_22                  (22+512)
 130          #define D_0_24                  (24+512)
 131          
 132          #define D_0_36                  (36)
 133          #define D_0_52                  (52)
 134          #define D_0_96                  (96)
 135          #define D_0_104                 (104)
 136          #define D_0_108                 (108)
 137          #define D_0_163                 (163)
 138          #define D_0_188                 (188)
 139          #define D_0_192                 (192)
 140          #define D_0_224                 (224)
 141          #define D_0_228                 (228)
 142          #define D_0_232                 (232)
 143          #define D_0_236                 (236)
 144          
 145          #define D_1_2                   (256 + 2)
 146          #define D_1_4                   (256 + 4)
 147          #define D_1_8                   (256 + 8)
 148          #define D_1_10                  (256 + 10)
 149          #define D_1_24                  (256 + 24)
 150          #define D_1_28                  (256 + 28)
 151          #define D_1_36                  (256 + 36)
 152          #define D_1_40                  (256 + 40)
 153          #define D_1_44                  (256 + 44)
 154          #define D_1_72                  (256 + 72)
 155          #define D_1_74                  (256 + 74)
 156          #define D_1_79                  (256 + 79)
 157          #define D_1_88                  (256 + 88)
 158          #define D_1_90                  (256 + 90)
 159          #define D_1_92                  (256 + 92)
 160          #define D_1_96                  (256 + 96)
 161          #define D_1_98                  (256 + 98)
 162          #define D_1_106                 (256 + 106)
 163          #define D_1_108                 (256 + 108)
 164          #define D_1_112                 (256 + 112)
 165          #define D_1_128                 (256 + 144)
 166          #define D_1_152                 (256 + 12)
 167          #define D_1_160                 (256 + 160)
 168          #define D_1_176                 (256 + 176)
 169          #define D_1_178                 (256 + 178)
 170          #define D_1_218                 (256 + 218)
 171          #define D_1_232                 (256 + 232)
 172          #define D_1_236                 (256 + 236)
 173          #define D_1_240                 (256 + 240)
 174          #define D_1_244                 (256 + 244)
 175          #define D_1_250                 (256 + 250)
 176          #define D_1_252                 (256 + 252)
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 4   

 177          #define D_2_12                  (512 + 12)
 178          #define D_2_96                  (512 + 96)
 179          #define D_2_108                 (512 + 108)
 180          #define D_2_208                 (512 + 208)
 181          #define D_2_224                 (512 + 224)
 182          #define D_2_236                 (512 + 236)
 183          #define D_2_244                 (512 + 244)
 184          #define D_2_248                 (512 + 248)
 185          #define D_2_252                 (512 + 252)
 186          
 187          #define CPASS_BIAS_X            (35 * 16 + 4)
 188          #define CPASS_BIAS_Y            (35 * 16 + 8)
 189          #define CPASS_BIAS_Z            (35 * 16 + 12)
 190          #define CPASS_MTX_00            (36 * 16)
 191          #define CPASS_MTX_01            (36 * 16 + 4)
 192          #define CPASS_MTX_02            (36 * 16 + 8)
 193          #define CPASS_MTX_10            (36 * 16 + 12)
 194          #define CPASS_MTX_11            (37 * 16)
 195          #define CPASS_MTX_12            (37 * 16 + 4)
 196          #define CPASS_MTX_20            (37 * 16 + 8)
 197          #define CPASS_MTX_21            (37 * 16 + 12)
 198          #define CPASS_MTX_22            (43 * 16 + 12)
 199          #define D_EXT_GYRO_BIAS_X       (61 * 16)
 200          #define D_EXT_GYRO_BIAS_Y       (61 * 16) + 4
 201          #define D_EXT_GYRO_BIAS_Z       (61 * 16) + 8
 202          #define D_ACT0                  (40 * 16)
 203          #define D_ACSX                  (40 * 16 + 4)
 204          #define D_ACSY                  (40 * 16 + 8)
 205          #define D_ACSZ                  (40 * 16 + 12)
 206          
 207          #define FLICK_MSG               (45 * 16 + 4)
 208          #define FLICK_COUNTER           (45 * 16 + 8)
 209          #define FLICK_LOWER             (45 * 16 + 12)
 210          #define FLICK_UPPER             (46 * 16 + 12)
 211          
 212          #define D_AUTH_OUT              (992)
 213          #define D_AUTH_IN               (996)
 214          #define D_AUTH_A                (1000)
 215          #define D_AUTH_B                (1004)
 216          
 217          #define D_PEDSTD_BP_B           (768 + 0x1C)
 218          #define D_PEDSTD_HP_A           (768 + 0x78)
 219          #define D_PEDSTD_HP_B           (768 + 0x7C)
 220          #define D_PEDSTD_BP_A4          (768 + 0x40)
 221          #define D_PEDSTD_BP_A3          (768 + 0x44)
 222          #define D_PEDSTD_BP_A2          (768 + 0x48)
 223          #define D_PEDSTD_BP_A1          (768 + 0x4C)
 224          #define D_PEDSTD_INT_THRSH      (768 + 0x68)
 225          #define D_PEDSTD_CLIP           (768 + 0x6C)
 226          #define D_PEDSTD_SB             (768 + 0x28)
 227          #define D_PEDSTD_SB_TIME        (768 + 0x2C)
 228          #define D_PEDSTD_PEAKTHRSH      (768 + 0x98)
 229          #define D_PEDSTD_TIML           (768 + 0x2A)
 230          #define D_PEDSTD_TIMH           (768 + 0x2E)
 231          #define D_PEDSTD_PEAK           (768 + 0X94)
 232          #define D_PEDSTD_STEPCTR        (768 + 0x60)
 233          #define D_PEDSTD_TIMECTR        (964)
 234          #define D_PEDSTD_DECI           (768 + 0xA0)
 235          
 236          #define D_HOST_NO_MOT           (976)
 237          #define D_ACCEL_BIAS            (660)
 238          
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 5   

 239          #define D_ORIENT_GAP            (76)
 240          
 241          #define D_TILT0_H               (48)
 242          #define D_TILT0_L               (50)
 243          #define D_TILT1_H               (52)
 244          #define D_TILT1_L               (54)
 245          #define D_TILT2_H               (56)
 246          #define D_TILT2_L               (58)
 247          #define D_TILT3_H               (60)
 248          #define D_TILT3_L               (62)
 249          
 250          #define DMP_CODE_SIZE           (3062)
 251          
 252          static const unsigned char dmp_memory[DMP_CODE_SIZE] = {
 253              /* bank # 0 */
 254              0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
 255              0x00, 0x65, 0x00, 0x54, 0xff, 0xef, 0x00, 0x00, 0xfa, 0x80, 0x00, 0x0b, 0x12, 0x82, 0x00, 0x01,
 256              0x03, 0x0c, 0x30, 0xc3, 0x0e, 0x8c, 0x8c, 0xe9, 0x14, 0xd5, 0x40, 0x02, 0x13, 0x71, 0x0f, 0x8e,
 257              0x38, 0x83, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83, 0x25, 0x8e, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83,
 258              0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xa9, 0xd6, 0x24, 0x00, 0x04, 0x00, 0x1a, 0x82, 0x79, 0xa1,
 259              0x00, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x83, 0x6f, 0xa2,
 260              0x00, 0x3e, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xca, 0xe3, 0x09, 0x3e, 0x80, 0x00, 0x00,
 261              0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
 262              0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x6e, 0x00, 0x00, 0x06, 0x92, 0x0a, 0x16, 0xc0, 0xdf,
 263              0xff, 0xff, 0x02, 0x56, 0xfd, 0x8c, 0xd3, 0x77, 0xff, 0xe1, 0xc4, 0x96, 0xe0, 0xc5, 0xbe, 0xaa,
 264              0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x2b, 0x00, 0x00, 0x16, 0x57, 0x00, 0x00, 0x03, 0x59,
 265              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xfa, 0x00, 0x02, 0x6c, 0x1d, 0x00, 0x00, 0x00, 0x00,
 266              0x3f, 0xff, 0xdf, 0xeb, 0x00, 0x3e, 0xb3, 0xb6, 0x00, 0x0d, 0x22, 0x78, 0x00, 0x00, 0x2f, 0x3c,
 267              0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x42, 0xb5, 0x00, 0x00, 0x39, 0xa2, 0x00, 0x00, 0xb3, 0x65,
 268              0xd9, 0x0e, 0x9f, 0xc9, 0x1d, 0xcf, 0x4c, 0x34, 0x30, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
 269              0x3b, 0xb6, 0x7a, 0xe8, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 270              /* bank # 1 */
 271              0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0xfa, 0x92, 0x10, 0x00, 0x22, 0x5e, 0x00, 0x0d, 0x22, 0x9f,
 272              0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0xff, 0x46, 0x00, 0x00, 0x63, 0xd4, 0x00, 0x00,
 273              0x10, 0x00, 0x00, 0x00, 0x04, 0xd6, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00,
 274              0x00, 0x00, 0x10, 0x72, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 275              0x00, 0x06, 0x00, 0x02, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
 276              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x64, 0x00, 0x20, 0x00, 0x00,
 277              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00,
 278              0x00, 0x00, 0x00, 0x32, 0xf8, 0x98, 0x00, 0x00, 0xff, 0x65, 0x00, 0x00, 0x83, 0x0f, 0x00, 0x00,
 279              0xff, 0x9b, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 280              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 281              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
 282              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xb2, 0x6a, 0x00, 0x02, 0x00, 0x00,
 283              0x00, 0x01, 0xfb, 0x83, 0x00, 0x68, 0x00, 0x00, 0x00, 0xd9, 0xfc, 0x00, 0x7c, 0xf1, 0xff, 0x83,
 284              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x64, 0x03, 0xe8, 0x00, 0x64, 0x00, 0x28,
 285              0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x16, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
 286              0x00, 0x00, 0x10, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x10, 0x00,
 287              /* bank # 2 */
 288              0x00, 0x28, 0x00, 0x00, 0xff, 0xff, 0x45, 0x81, 0xff, 0xff, 0xfa, 0x72, 0x00, 0x00, 0x00, 0x00,
 289              0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0x05, 0xba, 0xc6, 0x00, 0x47, 0x78, 0xa2,
 290              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
 291              0x00, 0x00, 0x25, 0x4d, 0x00, 0x2f, 0x70, 0x6d, 0x00, 0x00, 0x05, 0xae, 0x00, 0x0c, 0x02, 0xd0,
 292              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 293              0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 294              0x00, 0x64, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 295              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 296              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 297              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 298              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 299              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 300              0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e,
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 6   

 301              0x00, 0x00, 0x0a, 0xc7, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xff, 0xff, 0xff, 0x9c,
 302              0x00, 0x00, 0x0b, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64,
 303              0xff, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 304              /* bank # 3 */
 305              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 306              0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x24, 0x26, 0xd3,
 307              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x96, 0x00, 0x3c,
 308              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 309              0x0c, 0x0a, 0x4e, 0x68, 0xcd, 0xcf, 0x77, 0x09, 0x50, 0x16, 0x67, 0x59, 0xc6, 0x19, 0xce, 0x82,
 310              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 311              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xd7, 0x84, 0x00, 0x03, 0x00, 0x00, 0x00,
 312              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x93, 0x8f, 0x9d, 0x1e, 0x1b, 0x1c, 0x19,
 313              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 314              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x18, 0x85, 0x00, 0x00, 0x40, 0x00,
 315              0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 316              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 317              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 318              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 319              0x00, 0x00, 0x00, 0x00, 0x67, 0x7d, 0xdf, 0x7e, 0x72, 0x90, 0x2e, 0x55, 0x4c, 0xf6, 0xe6, 0x88,
 320              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 321          
 322              /* bank # 4 */
 323              0xd8, 0xdc, 0xb4, 0xb8, 0xb0, 0xd8, 0xb9, 0xab, 0xf3, 0xf8, 0xfa, 0xb3, 0xb7, 0xbb, 0x8e, 0x9e,
 324              0xae, 0xf1, 0x32, 0xf5, 0x1b, 0xf1, 0xb4, 0xb8, 0xb0, 0x80, 0x97, 0xf1, 0xa9, 0xdf, 0xdf, 0xdf,
 325              0xaa, 0xdf, 0xdf, 0xdf, 0xf2, 0xaa, 0xc5, 0xcd, 0xc7, 0xa9, 0x0c, 0xc9, 0x2c, 0x97, 0xf1, 0xa9,
 326              0x89, 0x26, 0x46, 0x66, 0xb2, 0x89, 0x99, 0xa9, 0x2d, 0x55, 0x7d, 0xb0, 0xb0, 0x8a, 0xa8, 0x96,
 327              0x36, 0x56, 0x76, 0xf1, 0xba, 0xa3, 0xb4, 0xb2, 0x80, 0xc0, 0xb8, 0xa8, 0x97, 0x11, 0xb2, 0x83,
 328              0x98, 0xba, 0xa3, 0xf0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xb2, 0xb9, 0xb4, 0x98, 0x83, 0xf1,
 329              0xa3, 0x29, 0x55, 0x7d, 0xba, 0xb5, 0xb1, 0xa3, 0x83, 0x93, 0xf0, 0x00, 0x28, 0x50, 0xf5, 0xb2,
 330              0xb6, 0xaa, 0x83, 0x93, 0x28, 0x54, 0x7c, 0xf1, 0xb9, 0xa3, 0x82, 0x93, 0x61, 0xba, 0xa2, 0xda,
 331              0xde, 0xdf, 0xdb, 0x81, 0x9a, 0xb9, 0xae, 0xf5, 0x60, 0x68, 0x70, 0xf1, 0xda, 0xba, 0xa2, 0xdf,
 332              0xd9, 0xba, 0xa2, 0xfa, 0xb9, 0xa3, 0x82, 0x92, 0xdb, 0x31, 0xba, 0xa2, 0xd9, 0xba, 0xa2, 0xf8,
 333              0xdf, 0x85, 0xa4, 0xd0, 0xc1, 0xbb, 0xad, 0x83, 0xc2, 0xc5, 0xc7, 0xb8, 0xa2, 0xdf, 0xdf, 0xdf,
 334              0xba, 0xa0, 0xdf, 0xdf, 0xdf, 0xd8, 0xd8, 0xf1, 0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35,
 335              0x5d, 0xb2, 0xb6, 0xba, 0xaf, 0x8c, 0x96, 0x19, 0x8f, 0x9f, 0xa7, 0x0e, 0x16, 0x1e, 0xb4, 0x9a,
 336              0xb8, 0xaa, 0x87, 0x2c, 0x54, 0x7c, 0xba, 0xa4, 0xb0, 0x8a, 0xb6, 0x91, 0x32, 0x56, 0x76, 0xb2,
 337              0x84, 0x94, 0xa4, 0xc8, 0x08, 0xcd, 0xd8, 0xb8, 0xb4, 0xb0, 0xf1, 0x99, 0x82, 0xa8, 0x2d, 0x55,
 338              0x7d, 0x98, 0xa8, 0x0e, 0x16, 0x1e, 0xa2, 0x2c, 0x54, 0x7c, 0x92, 0xa4, 0xf0, 0x2c, 0x50, 0x78,
 339              /* bank # 5 */
 340              0xf1, 0x84, 0xa8, 0x98, 0xc4, 0xcd, 0xfc, 0xd8, 0x0d, 0xdb, 0xa8, 0xfc, 0x2d, 0xf3, 0xd9, 0xba,
 341              0xa6, 0xf8, 0xda, 0xba, 0xa6, 0xde, 0xd8, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xf3, 0xc8,
 342              0x41, 0xda, 0xa6, 0xc8, 0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0x82, 0xa8, 0x92, 0xf5, 0x2c, 0x54, 0x88,
 343              0x98, 0xf1, 0x35, 0xd9, 0xf4, 0x18, 0xd8, 0xf1, 0xa2, 0xd0, 0xf8, 0xf9, 0xa8, 0x84, 0xd9, 0xc7,
 344              0xdf, 0xf8, 0xf8, 0x83, 0xc5, 0xda, 0xdf, 0x69, 0xdf, 0x83, 0xc1, 0xd8, 0xf4, 0x01, 0x14, 0xf1,
 345              0xa8, 0x82, 0x4e, 0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x28, 0x97, 0x88, 0xf1,
 346              0x09, 0xf4, 0x1c, 0x1c, 0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x29,
 347              0xf4, 0x0d, 0xd8, 0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc2, 0x03, 0xd8, 0xde, 0xdf, 0x1a,
 348              0xd8, 0xf1, 0xa2, 0xfa, 0xf9, 0xa8, 0x84, 0x98, 0xd9, 0xc7, 0xdf, 0xf8, 0xf8, 0xf8, 0x83, 0xc7,
 349              0xda, 0xdf, 0x69, 0xdf, 0xf8, 0x83, 0xc3, 0xd8, 0xf4, 0x01, 0x14, 0xf1, 0x98, 0xa8, 0x82, 0x2e,
 350              0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x50, 0x97, 0x88, 0xf1, 0x09, 0xf4, 0x1c,
 351              0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf8, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x49, 0xf4, 0x0d, 0xd8,
 352              0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc4, 0x03, 0xd8, 0xde, 0xdf, 0xd8, 0xf1, 0xad, 0x88,
 353              0x98, 0xcc, 0xa8, 0x09, 0xf9, 0xd9, 0x82, 0x92, 0xa8, 0xf5, 0x7c, 0xf1, 0x88, 0x3a, 0xcf, 0x94,
 354              0x4a, 0x6e, 0x98, 0xdb, 0x69, 0x31, 0xda, 0xad, 0xf2, 0xde, 0xf9, 0xd8, 0x87, 0x95, 0xa8, 0xf2,
 355              0x21, 0xd1, 0xda, 0xa5, 0xf9, 0xf4, 0x17, 0xd9, 0xf1, 0xae, 0x8e, 0xd0, 0xc0, 0xc3, 0xae, 0x82,
 356              /* bank # 6 */
 357              0xc6, 0x84, 0xc3, 0xa8, 0x85, 0x95, 0xc8, 0xa5, 0x88, 0xf2, 0xc0, 0xf1, 0xf4, 0x01, 0x0e, 0xf1,
 358              0x8e, 0x9e, 0xa8, 0xc6, 0x3e, 0x56, 0xf5, 0x54, 0xf1, 0x88, 0x72, 0xf4, 0x01, 0x15, 0xf1, 0x98,
 359              0x45, 0x85, 0x6e, 0xf5, 0x8e, 0x9e, 0x04, 0x88, 0xf1, 0x42, 0x98, 0x5a, 0x8e, 0x9e, 0x06, 0x88,
 360              0x69, 0xf4, 0x01, 0x1c, 0xf1, 0x98, 0x1e, 0x11, 0x08, 0xd0, 0xf5, 0x04, 0xf1, 0x1e, 0x97, 0x02,
 361              0x02, 0x98, 0x36, 0x25, 0xdb, 0xf9, 0xd9, 0x85, 0xa5, 0xf3, 0xc1, 0xda, 0x85, 0xa5, 0xf3, 0xdf,
 362              0xd8, 0x85, 0x95, 0xa8, 0xf3, 0x09, 0xda, 0xa5, 0xfa, 0xd8, 0x82, 0x92, 0xa8, 0xf5, 0x78, 0xf1,
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 7   

 363              0x88, 0x1a, 0x84, 0x9f, 0x26, 0x88, 0x98, 0x21, 0xda, 0xf4, 0x1d, 0xf3, 0xd8, 0x87, 0x9f, 0x39,
 364              0xd1, 0xaf, 0xd9, 0xdf, 0xdf, 0xfb, 0xf9, 0xf4, 0x0c, 0xf3, 0xd8, 0xfa, 0xd0, 0xf8, 0xda, 0xf9,
 365              0xf9, 0xd0, 0xdf, 0xd9, 0xf9, 0xd8, 0xf4, 0x0b, 0xd8, 0xf3, 0x87, 0x9f, 0x39, 0xd1, 0xaf, 0xd9,
 366              0xdf, 0xdf, 0xf4, 0x1d, 0xf3, 0xd8, 0xfa, 0xfc, 0xa8, 0x69, 0xf9, 0xf9, 0xaf, 0xd0, 0xda, 0xde,
 367              0xfa, 0xd9, 0xf8, 0x8f, 0x9f, 0xa8, 0xf1, 0xcc, 0xf3, 0x98, 0xdb, 0x45, 0xd9, 0xaf, 0xdf, 0xd0,
 368              0xf8, 0xd8, 0xf1, 0x8f, 0x9f, 0xa8, 0xca, 0xf3, 0x88, 0x09, 0xda, 0xaf, 0x8f, 0xcb, 0xf8, 0xd8,
 369              0xf2, 0xad, 0x97, 0x8d, 0x0c, 0xd9, 0xa5, 0xdf, 0xf9, 0xba, 0xa6, 0xf3, 0xfa, 0xf4, 0x12, 0xf2,
 370              0xd8, 0x95, 0x0d, 0xd1, 0xd9, 0xba, 0xa6, 0xf3, 0xfa, 0xda, 0xa5, 0xf2, 0xc1, 0xba, 0xa6, 0xf3,
 371              0xdf, 0xd8, 0xf1, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xca, 0xf3, 0x49, 0xda, 0xa6, 0xcb,
 372              0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0xd8, 0xad, 0x84, 0xf2, 0xc0, 0xdf, 0xf1, 0x8f, 0xcb, 0xc3, 0xa8,
 373              /* bank # 7 */
 374              0xb2, 0xb6, 0x86, 0x96, 0xc8, 0xc1, 0xcb, 0xc3, 0xf3, 0xb0, 0xb4, 0x88, 0x98, 0xa8, 0x21, 0xdb,
 375              0x71, 0x8d, 0x9d, 0x71, 0x85, 0x95, 0x21, 0xd9, 0xad, 0xf2, 0xfa, 0xd8, 0x85, 0x97, 0xa8, 0x28,
 376              0xd9, 0xf4, 0x08, 0xd8, 0xf2, 0x8d, 0x29, 0xda, 0xf4, 0x05, 0xd9, 0xf2, 0x85, 0xa4, 0xc2, 0xf2,
 377              0xd8, 0xa8, 0x8d, 0x94, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xf2, 0xd8, 0x87, 0x21, 0xd8, 0xf4, 0x0a,
 378              0xd8, 0xf2, 0x84, 0x98, 0xa8, 0xc8, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xd8, 0xf3, 0xa4, 0xc8, 0xbb,
 379              0xaf, 0xd0, 0xf2, 0xde, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xd8, 0xf1, 0xb8, 0xf6,
 380              0xb5, 0xb9, 0xb0, 0x8a, 0x95, 0xa3, 0xde, 0x3c, 0xa3, 0xd9, 0xf8, 0xd8, 0x5c, 0xa3, 0xd9, 0xf8,
 381              0xd8, 0x7c, 0xa3, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa5, 0xd9, 0xdf, 0xda, 0xfa, 0xd8, 0xb1,
 382              0x85, 0x30, 0xf7, 0xd9, 0xde, 0xd8, 0xf8, 0x30, 0xad, 0xda, 0xde, 0xd8, 0xf2, 0xb4, 0x8c, 0x99,
 383              0xa3, 0x2d, 0x55, 0x7d, 0xa0, 0x83, 0xdf, 0xdf, 0xdf, 0xb5, 0x91, 0xa0, 0xf6, 0x29, 0xd9, 0xfb,
 384              0xd8, 0xa0, 0xfc, 0x29, 0xd9, 0xfa, 0xd8, 0xa0, 0xd0, 0x51, 0xd9, 0xf8, 0xd8, 0xfc, 0x51, 0xd9,
 385              0xf9, 0xd8, 0x79, 0xd9, 0xfb, 0xd8, 0xa0, 0xd0, 0xfc, 0x79, 0xd9, 0xfa, 0xd8, 0xa1, 0xf9, 0xf9,
 386              0xf9, 0xf9, 0xf9, 0xa0, 0xda, 0xdf, 0xdf, 0xdf, 0xd8, 0xa1, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xac,
 387              0xde, 0xf8, 0xad, 0xde, 0x83, 0x93, 0xac, 0x2c, 0x54, 0x7c, 0xf1, 0xa8, 0xdf, 0xdf, 0xdf, 0xf6,
 388              0x9d, 0x2c, 0xda, 0xa0, 0xdf, 0xd9, 0xfa, 0xdb, 0x2d, 0xf8, 0xd8, 0xa8, 0x50, 0xda, 0xa0, 0xd0,
 389              0xde, 0xd9, 0xd0, 0xf8, 0xf8, 0xf8, 0xdb, 0x55, 0xf8, 0xd8, 0xa8, 0x78, 0xda, 0xa0, 0xd0, 0xdf,
 390              /* bank # 8 */
 391              0xd9, 0xd0, 0xfa, 0xf8, 0xf8, 0xf8, 0xf8, 0xdb, 0x7d, 0xf8, 0xd8, 0x9c, 0xa8, 0x8c, 0xf5, 0x30,
 392              0xdb, 0x38, 0xd9, 0xd0, 0xde, 0xdf, 0xa0, 0xd0, 0xde, 0xdf, 0xd8, 0xa8, 0x48, 0xdb, 0x58, 0xd9,
 393              0xdf, 0xd0, 0xde, 0xa0, 0xdf, 0xd0, 0xde, 0xd8, 0xa8, 0x68, 0xdb, 0x70, 0xd9, 0xdf, 0xdf, 0xa0,
 394              0xdf, 0xdf, 0xd8, 0xf1, 0xa8, 0x88, 0x90, 0x2c, 0x54, 0x7c, 0x98, 0xa8, 0xd0, 0x5c, 0x38, 0xd1,
 395              0xda, 0xf2, 0xae, 0x8c, 0xdf, 0xf9, 0xd8, 0xb0, 0x87, 0xa8, 0xc1, 0xc1, 0xb1, 0x88, 0xa8, 0xc6,
 396              0xf9, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8,
 397              0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xf7, 0x8d, 0x9d, 0xad, 0xf8, 0x18, 0xda,
 398              0xf2, 0xae, 0xdf, 0xd8, 0xf7, 0xad, 0xfa, 0x30, 0xd9, 0xa4, 0xde, 0xf9, 0xd8, 0xf2, 0xae, 0xde,
 399              0xfa, 0xf9, 0x83, 0xa7, 0xd9, 0xc3, 0xc5, 0xc7, 0xf1, 0x88, 0x9b, 0xa7, 0x7a, 0xad, 0xf7, 0xde,
 400              0xdf, 0xa4, 0xf8, 0x84, 0x94, 0x08, 0xa7, 0x97, 0xf3, 0x00, 0xae, 0xf2, 0x98, 0x19, 0xa4, 0x88,
 401              0xc6, 0xa3, 0x94, 0x88, 0xf6, 0x32, 0xdf, 0xf2, 0x83, 0x93, 0xdb, 0x09, 0xd9, 0xf2, 0xaa, 0xdf,
 402              0xd8, 0xd8, 0xae, 0xf8, 0xf9, 0xd1, 0xda, 0xf3, 0xa4, 0xde, 0xa7, 0xf1, 0x88, 0x9b, 0x7a, 0xd8,
 403              0xf3, 0x84, 0x94, 0xae, 0x19, 0xf9, 0xda, 0xaa, 0xf1, 0xdf, 0xd8, 0xa8, 0x81, 0xc0, 0xc3, 0xc5,
 404              0xc7, 0xa3, 0x92, 0x83, 0xf6, 0x28, 0xad, 0xde, 0xd9, 0xf8, 0xd8, 0xa3, 0x50, 0xad, 0xd9, 0xf8,
 405              0xd8, 0xa3, 0x78, 0xad, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa1, 0xda, 0xde, 0xc3, 0xc5, 0xc7,
 406              0xd8, 0xa1, 0x81, 0x94, 0xf8, 0x18, 0xf2, 0xb0, 0x89, 0xac, 0xc3, 0xc5, 0xc7, 0xf1, 0xd8, 0xb8,
 407              /* bank # 9 */
 408              0xb4, 0xb0, 0x97, 0x86, 0xa8, 0x31, 0x9b, 0x06, 0x99, 0x07, 0xab, 0x97, 0x28, 0x88, 0x9b, 0xf0,
 409              0x0c, 0x20, 0x14, 0x40, 0xb0, 0xb4, 0xb8, 0xf0, 0xa8, 0x8a, 0x9a, 0x28, 0x50, 0x78, 0xb7, 0x9b,
 410              0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xf1, 0xbb, 0xab,
 411              0x88, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0xb3, 0x8b, 0xb8, 0xa8, 0x04, 0x28, 0x50, 0x78, 0xf1, 0xb0,
 412              0x88, 0xb4, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xbb, 0xab, 0xb3, 0x8b, 0x02, 0x26, 0x46, 0x66, 0xb0,
 413              0xb8, 0xf0, 0x8a, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x8b, 0x29, 0x51, 0x79, 0x8a, 0x24, 0x70, 0x59,
 414              0x8b, 0x20, 0x58, 0x71, 0x8a, 0x44, 0x69, 0x38, 0x8b, 0x39, 0x40, 0x68, 0x8a, 0x64, 0x48, 0x31,
 415              0x8b, 0x30, 0x49, 0x60, 0x88, 0xf1, 0xac, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0x8c, 0xa8, 0x04, 0x28,
 416              0x50, 0x78, 0xf1, 0x88, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xac, 0x8c, 0x02, 0x26, 0x46, 0x66, 0xf0,
 417              0x89, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xa9,
 418              0x88, 0x09, 0x20, 0x59, 0x70, 0xab, 0x11, 0x38, 0x40, 0x69, 0xa8, 0x19, 0x31, 0x48, 0x60, 0x8c,
 419              0xa8, 0x3c, 0x41, 0x5c, 0x20, 0x7c, 0x00, 0xf1, 0x87, 0x98, 0x19, 0x86, 0xa8, 0x6e, 0x76, 0x7e,
 420              0xa9, 0x99, 0x88, 0x2d, 0x55, 0x7d, 0xd8, 0xb1, 0xb5, 0xb9, 0xa3, 0xdf, 0xdf, 0xdf, 0xae, 0xd0,
 421              0xdf, 0xaa, 0xd0, 0xde, 0xf2, 0xab, 0xf8, 0xf9, 0xd9, 0xb0, 0x87, 0xc4, 0xaa, 0xf1, 0xdf, 0xdf,
 422              0xbb, 0xaf, 0xdf, 0xdf, 0xb9, 0xd8, 0xb1, 0xf1, 0xa3, 0x97, 0x8e, 0x60, 0xdf, 0xb0, 0x84, 0xf2,
 423              0xc8, 0xf8, 0xf9, 0xd9, 0xde, 0xd8, 0x93, 0x85, 0xf1, 0x4a, 0xb1, 0x83, 0xa3, 0x08, 0xb5, 0x83,
 424              /* bank # 10 */
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 8   

 425              0x9a, 0x08, 0x10, 0xb7, 0x9f, 0x10, 0xd8, 0xf1, 0xb0, 0xba, 0xae, 0xb0, 0x8a, 0xc2, 0xb2, 0xb6,
 426              0x8e, 0x9e, 0xf1, 0xfb, 0xd9, 0xf4, 0x1d, 0xd8, 0xf9, 0xd9, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad,
 427              0x61, 0xd9, 0xae, 0xfb, 0xd8, 0xf4, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad, 0x19, 0xd9, 0xae, 0xfb,
 428              0xdf, 0xd8, 0xf4, 0x16, 0xf1, 0xd8, 0xf8, 0xad, 0x8d, 0x61, 0xd9, 0xf4, 0xf4, 0xac, 0xf5, 0x9c,
 429              0x9c, 0x8d, 0xdf, 0x2b, 0xba, 0xb6, 0xae, 0xfa, 0xf8, 0xf4, 0x0b, 0xd8, 0xf1, 0xae, 0xd0, 0xf8,
 430              0xad, 0x51, 0xda, 0xae, 0xfa, 0xf8, 0xf1, 0xd8, 0xb9, 0xb1, 0xb6, 0xa3, 0x83, 0x9c, 0x08, 0xb9,
 431              0xb1, 0x83, 0x9a, 0xb5, 0xaa, 0xc0, 0xfd, 0x30, 0x83, 0xb7, 0x9f, 0x10, 0xb5, 0x8b, 0x93, 0xf2,
 432              0x02, 0x02, 0xd1, 0xab, 0xda, 0xde, 0xd8, 0xf1, 0xb0, 0x80, 0xba, 0xab, 0xc0, 0xc3, 0xb2, 0x84,
 433              0xc1, 0xc3, 0xd8, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0x09, 0xb4, 0xd9, 0xab, 0xde, 0xb0,
 434              0x87, 0x9c, 0xb9, 0xa3, 0xdd, 0xf1, 0xb3, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0xb0, 0x87, 0xa3, 0xa3,
 435              0xa3, 0xa3, 0xb2, 0x8b, 0xb6, 0x9b, 0xf2, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
 436              0xa3, 0xf1, 0xb0, 0x87, 0xb5, 0x9a, 0xa3, 0xf3, 0x9b, 0xa3, 0xa3, 0xdc, 0xba, 0xac, 0xdf, 0xb9,
 437              0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
 438              0xd8, 0xd8, 0xd8, 0xbb, 0xb3, 0xb7, 0xf1, 0xaa, 0xf9, 0xda, 0xff, 0xd9, 0x80, 0x9a, 0xaa, 0x28,
 439              0xb4, 0x80, 0x98, 0xa7, 0x20, 0xb7, 0x97, 0x87, 0xa8, 0x66, 0x88, 0xf0, 0x79, 0x51, 0xf1, 0x90,
 440              0x2c, 0x87, 0x0c, 0xa7, 0x81, 0x97, 0x62, 0x93, 0xf0, 0x71, 0x71, 0x60, 0x85, 0x94, 0x01, 0x29,
 441              /* bank # 11 */
 442              0x51, 0x79, 0x90, 0xa5, 0xf1, 0x28, 0x4c, 0x6c, 0x87, 0x0c, 0x95, 0x18, 0x85, 0x78, 0xa3, 0x83,
 443              0x90, 0x28, 0x4c, 0x6c, 0x88, 0x6c, 0xd8, 0xf3, 0xa2, 0x82, 0x00, 0xf2, 0x10, 0xa8, 0x92, 0x19,
 444              0x80, 0xa2, 0xf2, 0xd9, 0x26, 0xd8, 0xf1, 0x88, 0xa8, 0x4d, 0xd9, 0x48, 0xd8, 0x96, 0xa8, 0x39,
 445              0x80, 0xd9, 0x3c, 0xd8, 0x95, 0x80, 0xa8, 0x39, 0xa6, 0x86, 0x98, 0xd9, 0x2c, 0xda, 0x87, 0xa7,
 446              0x2c, 0xd8, 0xa8, 0x89, 0x95, 0x19, 0xa9, 0x80, 0xd9, 0x38, 0xd8, 0xa8, 0x89, 0x39, 0xa9, 0x80,
 447              0xda, 0x3c, 0xd8, 0xa8, 0x2e, 0xa8, 0x39, 0x90, 0xd9, 0x0c, 0xd8, 0xa8, 0x95, 0x31, 0x98, 0xd9,
 448              0x0c, 0xd8, 0xa8, 0x09, 0xd9, 0xff, 0xd8, 0x01, 0xda, 0xff, 0xd8, 0x95, 0x39, 0xa9, 0xda, 0x26,
 449              0xff, 0xd8, 0x90, 0xa8, 0x0d, 0x89, 0x99, 0xa8, 0x10, 0x80, 0x98, 0x21, 0xda, 0x2e, 0xd8, 0x89,
 450              0x99, 0xa8, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x86, 0x96, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8,
 451              0x87, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x82, 0x92, 0xf3, 0x41, 0x80, 0xf1, 0xd9, 0x2e, 0xd8,
 452              0xa8, 0x82, 0xf3, 0x19, 0x80, 0xf1, 0xd9, 0x2e, 0xd8, 0x82, 0xac, 0xf3, 0xc0, 0xa2, 0x80, 0x22,
 453              0xf1, 0xa6, 0x2e, 0xa7, 0x2e, 0xa9, 0x22, 0x98, 0xa8, 0x29, 0xda, 0xac, 0xde, 0xff, 0xd8, 0xa2,
 454              0xf2, 0x2a, 0xf1, 0xa9, 0x2e, 0x82, 0x92, 0xa8, 0xf2, 0x31, 0x80, 0xa6, 0x96, 0xf1, 0xd9, 0x00,
 455              0xac, 0x8c, 0x9c, 0x0c, 0x30, 0xac, 0xde, 0xd0, 0xde, 0xff, 0xd8, 0x8c, 0x9c, 0xac, 0xd0, 0x10,
 456              0xac, 0xde, 0x80, 0x92, 0xa2, 0xf2, 0x4c, 0x82, 0xa8, 0xf1, 0xca, 0xf2, 0x35, 0xf1, 0x96, 0x88,
 457              0xa6, 0xd9, 0x00, 0xd8, 0xf1, 0xff
 458          };
 459          
 460          static const unsigned short sStartAddress = 0x0400;
 461          
 462          /* END OF SECTION COPIED FROM dmpDefaultMPU6050.c */
 463          
 464          #define INT_SRC_TAP             (0x01)
 465          #define INT_SRC_ANDROID_ORIENT  (0x08)
 466          
 467          #define DMP_FEATURE_SEND_ANY_GYRO   (DMP_FEATURE_SEND_RAW_GYRO | \
 468                                               DMP_FEATURE_SEND_CAL_GYRO)
 469          
 470          #define MAX_PACKET_LENGTH   (32)
 471          
 472          #define DMP_SAMPLE_RATE     (200)
 473          #define GYRO_SF             (46850825LL * 200 / DMP_SAMPLE_RATE)
 474          
 475          #define FIFO_CORRUPTION_CHECK
 476          #ifdef FIFO_CORRUPTION_CHECK
 477          #define QUAT_ERROR_THRESH       (1L<<24)
 478          #define QUAT_MAG_SQ_NORMALIZED  (1L<<28)
 479          #define QUAT_MAG_SQ_MIN         (QUAT_MAG_SQ_NORMALIZED - QUAT_ERROR_THRESH)
 480          #define QUAT_MAG_SQ_MAX         (QUAT_MAG_SQ_NORMALIZED + QUAT_ERROR_THRESH)
 481          #endif
 482          
 483          struct dmp_s {
 484              void (*tap_cb)(unsigned char count, unsigned char direction);
 485              void (*android_orient_cb)(unsigned char orientation);
 486              unsigned short orient;
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 9   

 487              unsigned short feature_mask;
 488              unsigned short fifo_rate;
 489              unsigned char packet_length;
 490          };
 491          
 492          //static struct dmp_s dmp = {
 493          //    .tap_cb = NULL,
 494          //    .android_orient_cb = NULL,
 495          //    .orient = 0,
 496          //    .feature_mask = 0,
 497          //    .fifo_rate = 0,
 498          //    .packet_length = 0
 499          //};
 500          
 501          static struct dmp_s dmp={
 502            NULL,
 503            NULL,
 504            0,
 505            0,
 506            0,
 507            0
 508          };
 509          
 510          /**
 511           *  @brief  Load the DMP with this image.
 512           *  @return 0 if successful.
 513           */
 514          int dmp_load_motion_driver_firmware(void)
 515          {
 516   1          return mpu_load_firmware(DMP_CODE_SIZE, dmp_memory, sStartAddress,
 517   1              DMP_SAMPLE_RATE);
 518   1      }
 519          
 520          /**
 521           *  @brief      Push gyro and accel orientation to the DMP.
 522           *  The orientation is represented here as the output of
 523           *  @e inv_orientation_matrix_to_scalar.
 524           *  @param[in]  orient  Gyro and accel orientation in body frame.
 525           *  @return     0 if successful.
 526           */
 527          int dmp_set_orientation(unsigned short orient)
 528          {
 529   1          unsigned char gyro_regs[3], accel_regs[3];
 530   1          const unsigned char gyro_axes[3] = {DINA4C, DINACD, DINA6C};
 531   1          const unsigned char accel_axes[3] = {DINA0C, DINAC9, DINA2C};
 532   1          const unsigned char gyro_sign[3] = {DINA36, DINA56, DINA76};
 533   1          const unsigned char accel_sign[3] = {DINA26, DINA46, DINA66};
 534   1      
 535   1          gyro_regs[0] = gyro_axes[orient & 3];
 536   1          gyro_regs[1] = gyro_axes[(orient >> 3) & 3];
 537   1          gyro_regs[2] = gyro_axes[(orient >> 6) & 3];
 538   1          accel_regs[0] = accel_axes[orient & 3];
 539   1          accel_regs[1] = accel_axes[(orient >> 3) & 3];
 540   1          accel_regs[2] = accel_axes[(orient >> 6) & 3];
 541   1      
 542   1          /* Chip-to-body, axes only. */
 543   1          if (mpu_write_mem(FCFG_1, 3, gyro_regs))
 544   1              return -1;
 545   1          if (mpu_write_mem(FCFG_2, 3, accel_regs))
 546   1              return -1;
 547   1      
 548   1          memcpy(gyro_regs, gyro_sign, 3);
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 10  

 549   1          memcpy(accel_regs, accel_sign, 3);
 550   1          if (orient & 4) {
 551   2              gyro_regs[0] |= 1;
 552   2              accel_regs[0] |= 1;
 553   2          }
 554   1          if (orient & 0x20) {
 555   2              gyro_regs[1] |= 1;
 556   2              accel_regs[1] |= 1;
 557   2          }
 558   1          if (orient & 0x100) {
 559   2              gyro_regs[2] |= 1;
 560   2              accel_regs[2] |= 1;
 561   2          }
 562   1      
 563   1          /* Chip-to-body, sign only. */
 564   1          if (mpu_write_mem(FCFG_3, 3, gyro_regs))
 565   1              return -1;
 566   1          if (mpu_write_mem(FCFG_7, 3, accel_regs))
 567   1              return -1;
 568   1          dmp.orient = orient;
 569   1          return 0;
 570   1      }
 571          
 572          /**
 573           *  @brief      Push gyro biases to the DMP.
 574           *  Because the gyro integration is handled in the DMP, any gyro biases
 575           *  calculated by the MPL should be pushed down to DMP memory to remove
 576           *  3-axis quaternion drift.
 577           *  \n NOTE: If the DMP-based gyro calibration is enabled, the DMP will
 578           *  overwrite the biases written to this location once a new one is computed.
 579           *  @param[in]  bias    Gyro biases in q16.
 580           *  @return     0 if successful.
 581           */
 582          int dmp_set_gyro_bias(long *bias)
 583          {
 584   1          long gyro_bias_body[3];
 585   1          unsigned char regs[4];
 586   1      
 587   1          gyro_bias_body[0] = bias[dmp.orient & 3];
 588   1          if (dmp.orient & 4)
 589   1              gyro_bias_body[0] *= -1;
 590   1          gyro_bias_body[1] = bias[(dmp.orient >> 3) & 3];
 591   1          if (dmp.orient & 0x20)
 592   1              gyro_bias_body[1] *= -1;
 593   1          gyro_bias_body[2] = bias[(dmp.orient >> 6) & 3];
 594   1          if (dmp.orient & 0x100)
 595   1              gyro_bias_body[2] *= -1;
 596   1      
 597   1      #ifdef EMPL_NO_64BIT
                  gyro_bias_body[0] = (long)(((float)gyro_bias_body[0] * GYRO_SF) / 1073741824.f);
                  gyro_bias_body[1] = (long)(((float)gyro_bias_body[1] * GYRO_SF) / 1073741824.f);
                  gyro_bias_body[2] = (long)(((float)gyro_bias_body[2] * GYRO_SF) / 1073741824.f);
              #else
 602   1          gyro_bias_body[0] = (long)(((long long)gyro_bias_body[0] * GYRO_SF) >> 30);
*** ERROR C141 IN LINE 602 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
*** ERROR C141 IN LINE 602 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
*** ERROR C202 IN LINE 602 OF DMP\inv_mpu_dmp_motion_driver.c: 'L': undefined identifier
*** ERROR C141 IN LINE 602 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 602 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
 603   1          gyro_bias_body[1] = (long)(((long long)gyro_bias_body[1] * GYRO_SF) >> 30);
*** ERROR C141 IN LINE 603 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
*** ERROR C141 IN LINE 603 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 11  

*** ERROR C141 IN LINE 603 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 603 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
 604   1          gyro_bias_body[2] = (long)(((long long)gyro_bias_body[2] * GYRO_SF) >> 30);
*** ERROR C141 IN LINE 604 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
*** ERROR C141 IN LINE 604 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
*** ERROR C141 IN LINE 604 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 604 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
 605   1      #endif
 606   1      
 607   1          regs[0] = (unsigned char)((gyro_bias_body[0] >> 24) & 0xFF);
 608   1          regs[1] = (unsigned char)((gyro_bias_body[0] >> 16) & 0xFF);
 609   1          regs[2] = (unsigned char)((gyro_bias_body[0] >> 8) & 0xFF);
 610   1          regs[3] = (unsigned char)(gyro_bias_body[0] & 0xFF);
 611   1          if (mpu_write_mem(D_EXT_GYRO_BIAS_X, 4, regs))
 612   1              return -1;
 613   1      
 614   1          regs[0] = (unsigned char)((gyro_bias_body[1] >> 24) & 0xFF);
 615   1          regs[1] = (unsigned char)((gyro_bias_body[1] >> 16) & 0xFF);
 616   1          regs[2] = (unsigned char)((gyro_bias_body[1] >> 8) & 0xFF);
 617   1          regs[3] = (unsigned char)(gyro_bias_body[1] & 0xFF);
 618   1          if (mpu_write_mem(D_EXT_GYRO_BIAS_Y, 4, regs))
 619   1              return -1;
 620   1      
 621   1          regs[0] = (unsigned char)((gyro_bias_body[2] >> 24) & 0xFF);
 622   1          regs[1] = (unsigned char)((gyro_bias_body[2] >> 16) & 0xFF);
 623   1          regs[2] = (unsigned char)((gyro_bias_body[2] >> 8) & 0xFF);
 624   1          regs[3] = (unsigned char)(gyro_bias_body[2] & 0xFF);
 625   1          return mpu_write_mem(D_EXT_GYRO_BIAS_Z, 4, regs);
 626   1      }
 627          
 628          /**
 629           *  @brief      Push accel biases to the DMP.
 630           *  These biases will be removed from the DMP 6-axis quaternion.
 631           *  @param[in]  bias    Accel biases in q16.
 632           *  @return     0 if successful.
 633           */
 634          int dmp_set_accel_bias(long *bias)
 635          {
 636   1          long accel_bias_body[3];
 637   1          unsigned char regs[12];
 638   1          long long accel_sf;
*** ERROR C141 IN LINE 638 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long'
 639   1          unsigned short accel_sens;
 640   1      
 641   1          mpu_get_accel_sens(&accel_sens);
 642   1          accel_sf = (long long)accel_sens << 15;
*** ERROR C141 IN LINE 642 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
 643   1          //__no_operation();
 644   1      
 645   1          accel_bias_body[0] = bias[dmp.orient & 3];
 646   1          if (dmp.orient & 4)
 647   1              accel_bias_body[0] *= -1;
 648   1          accel_bias_body[1] = bias[(dmp.orient >> 3) & 3];
 649   1          if (dmp.orient & 0x20)
 650   1              accel_bias_body[1] *= -1;
 651   1          accel_bias_body[2] = bias[(dmp.orient >> 6) & 3];
 652   1          if (dmp.orient & 0x100)
 653   1              accel_bias_body[2] *= -1;
 654   1      
 655   1      #ifdef EMPL_NO_64BIT
                  accel_bias_body[0] = (long)(((float)accel_bias_body[0] * accel_sf) / 1073741824.f);
                  accel_bias_body[1] = (long)(((float)accel_bias_body[1] * accel_sf) / 1073741824.f);
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 12  

                  accel_bias_body[2] = (long)(((float)accel_bias_body[2] * accel_sf) / 1073741824.f);
              #else
 660   1          accel_bias_body[0] = (long)(((long long)accel_bias_body[0] * accel_sf) >> 30);
*** ERROR C141 IN LINE 660 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
 661   1          accel_bias_body[1] = (long)(((long long)accel_bias_body[1] * accel_sf) >> 30);
*** ERROR C141 IN LINE 661 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
 662   1          accel_bias_body[2] = (long)(((long long)accel_bias_body[2] * accel_sf) >> 30);
*** ERROR C141 IN LINE 662 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'long', expected ')'
 663   1      #endif
 664   1      
 665   1          regs[0] = (unsigned char)((accel_bias_body[0] >> 24) & 0xFF);
 666   1          regs[1] = (unsigned char)((accel_bias_body[0] >> 16) & 0xFF);
 667   1          regs[2] = (unsigned char)((accel_bias_body[0] >> 8) & 0xFF);
 668   1          regs[3] = (unsigned char)(accel_bias_body[0] & 0xFF);
 669   1          regs[4] = (unsigned char)((accel_bias_body[1] >> 24) & 0xFF);
 670   1          regs[5] = (unsigned char)((accel_bias_body[1] >> 16) & 0xFF);
 671   1          regs[6] = (unsigned char)((accel_bias_body[1] >> 8) & 0xFF);
 672   1          regs[7] = (unsigned char)(accel_bias_body[1] & 0xFF);
 673   1          regs[8] = (unsigned char)((accel_bias_body[2] >> 24) & 0xFF);
 674   1          regs[9] = (unsigned char)((accel_bias_body[2] >> 16) & 0xFF);
 675   1          regs[10] = (unsigned char)((accel_bias_body[2] >> 8) & 0xFF);
 676   1          regs[11] = (unsigned char)(accel_bias_body[2] & 0xFF);
 677   1          return mpu_write_mem(D_ACCEL_BIAS, 12, regs);
 678   1      }
 679          
 680          /**
 681           *  @brief      Set DMP output rate.
 682           *  Only used when DMP is on.
 683           *  @param[in]  rate    Desired fifo rate (Hz).
 684           *  @return     0 if successful.
 685           */
 686          int dmp_set_fifo_rate(unsigned short rate)
 687          {
 688   1          const unsigned char regs_end[12] = {DINAFE, DINAF2, DINAAB,
 689   1              0xc4, DINAAA, DINAF1, DINADF, DINADF, 0xBB, 0xAF, DINADF, DINADF};
 690   1          unsigned short div;
 691   1          unsigned char tmp[8];
 692   1      
 693   1          if (rate > DMP_SAMPLE_RATE)
 694   1              return -1;
 695   1          div = DMP_SAMPLE_RATE / rate - 1;
 696   1          tmp[0] = (unsigned char)((div >> 8) & 0xFF);
 697   1          tmp[1] = (unsigned char)(div & 0xFF);
 698   1          if (mpu_write_mem(D_0_22, 2, tmp))
 699   1              return -1;
 700   1          if (mpu_write_mem(CFG_6, 12, (unsigned char*)regs_end))
 701   1              return -1;
 702   1      
 703   1          dmp.fifo_rate = rate;
 704   1          return 0;
 705   1      }
 706          
 707          /**
 708           *  @brief      Get DMP output rate.
 709           *  @param[out] rate    Current fifo rate (Hz).
 710           *  @return     0 if successful.
 711           */
 712          int dmp_get_fifo_rate(unsigned short *rate)
 713          {
 714   1          rate[0] = dmp.fifo_rate;
 715   1          return 0;
 716   1      }
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 13  

 717          
 718          /**
 719           *  @brief      Set tap threshold for a specific axis.
 720           *  @param[in]  axis    1, 2, and 4 for XYZ accel, respectively.
 721           *  @param[in]  thresh  Tap threshold, in mg/ms.
 722           *  @return     0 if successful.
 723           */
 724          int dmp_set_tap_thresh(unsigned char axis, unsigned short thresh)
 725          {
 726   1          unsigned char tmp[4], accel_fsr;
 727   1          float scaled_thresh;
 728   1          unsigned short dmp_thresh, dmp_thresh_2;
 729   1          if (!(axis & TAP_XYZ) || thresh > 1600)
 730   1              return -1;
 731   1      
 732   1          scaled_thresh = (float)thresh / DMP_SAMPLE_RATE;
 733   1      
 734   1          mpu_get_accel_fsr(&accel_fsr);
 735   1          switch (accel_fsr) {
 736   2          case 2:
 737   2              dmp_thresh = (unsigned short)(scaled_thresh * 16384);
 738   2              /* dmp_thresh * 0.75 */
 739   2              dmp_thresh_2 = (unsigned short)(scaled_thresh * 12288);
 740   2              break;
 741   2          case 4:
 742   2              dmp_thresh = (unsigned short)(scaled_thresh * 8192);
 743   2              /* dmp_thresh * 0.75 */
 744   2              dmp_thresh_2 = (unsigned short)(scaled_thresh * 6144);
 745   2              break;
 746   2          case 8:
 747   2              dmp_thresh = (unsigned short)(scaled_thresh * 4096);
 748   2              /* dmp_thresh * 0.75 */
 749   2              dmp_thresh_2 = (unsigned short)(scaled_thresh * 3072);
 750   2              break;
 751   2          case 16:
 752   2              dmp_thresh = (unsigned short)(scaled_thresh * 2048);
 753   2              /* dmp_thresh * 0.75 */
 754   2              dmp_thresh_2 = (unsigned short)(scaled_thresh * 1536);
 755   2              break;
 756   2          default:
 757   2              return -1;
 758   2          }
 759   1          tmp[0] = (unsigned char)(dmp_thresh >> 8);
 760   1          tmp[1] = (unsigned char)(dmp_thresh & 0xFF);
 761   1          tmp[2] = (unsigned char)(dmp_thresh_2 >> 8);
 762   1          tmp[3] = (unsigned char)(dmp_thresh_2 & 0xFF);
 763   1      
 764   1          if (axis & TAP_X) {
 765   2              if (mpu_write_mem(DMP_TAP_THX, 2, tmp))
 766   2                  return -1;
 767   2              if (mpu_write_mem(D_1_36, 2, tmp+2))
 768   2                  return -1;
 769   2          }
 770   1          if (axis & TAP_Y) {
 771   2              if (mpu_write_mem(DMP_TAP_THY, 2, tmp))
 772   2                  return -1;
 773   2              if (mpu_write_mem(D_1_40, 2, tmp+2))
 774   2                  return -1;
 775   2          }
 776   1          if (axis & TAP_Z) {
 777   2              if (mpu_write_mem(DMP_TAP_THZ, 2, tmp))
 778   2                  return -1;
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 14  

 779   2              if (mpu_write_mem(D_1_44, 2, tmp+2))
 780   2                  return -1;
 781   2          }
 782   1          return 0;
 783   1      }
 784          
 785          /**
 786           *  @brief      Set which axes will register a tap.
 787           *  @param[in]  axis    1, 2, and 4 for XYZ, respectively.
 788           *  @return     0 if successful.
 789           */
 790          int dmp_set_tap_axes(unsigned char axis)
 791          {
 792   1          unsigned char tmp = 0;
 793   1      
 794   1          if (axis & TAP_X)
 795   1              tmp |= 0x30;
 796   1          if (axis & TAP_Y)
 797   1              tmp |= 0x0C;
 798   1          if (axis & TAP_Z)
 799   1              tmp |= 0x03;
 800   1          return mpu_write_mem(D_1_72, 1, &tmp);
 801   1      }
 802          
 803          /**
 804           *  @brief      Set minimum number of taps needed for an interrupt.
 805           *  @param[in]  min_taps    Minimum consecutive taps (1-4).
 806           *  @return     0 if successful.
 807           */
 808          int dmp_set_tap_count(unsigned char min_taps)
 809          {
 810   1          unsigned char tmp;
 811   1      
 812   1          if (min_taps < 1)
 813   1              min_taps = 1;
 814   1          else if (min_taps > 4)
 815   1              min_taps = 4;
 816   1      
 817   1          tmp = min_taps - 1;
 818   1          return mpu_write_mem(D_1_79, 1, &tmp);
 819   1      }
 820          
 821          /**
 822           *  @brief      Set length between valid taps.
 823           *  @param[in]  time    Milliseconds between taps.
 824           *  @return     0 if successful.
 825           */
 826          int dmp_set_tap_time(unsigned short time)
 827          {
 828   1          unsigned short dmp_time;
 829   1          unsigned char tmp[2];
 830   1      
 831   1          dmp_time = time / (1000 / DMP_SAMPLE_RATE);
 832   1          tmp[0] = (unsigned char)(dmp_time >> 8);
 833   1          tmp[1] = (unsigned char)(dmp_time & 0xFF);
 834   1          return mpu_write_mem(DMP_TAPW_MIN, 2, tmp);
 835   1      }
 836          
 837          /**
 838           *  @brief      Set max time between taps to register as a multi-tap.
 839           *  @param[in]  time    Max milliseconds between taps.
 840           *  @return     0 if successful.
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 15  

 841           */
 842          int dmp_set_tap_time_multi(unsigned short time)
 843          {
 844   1          unsigned short dmp_time;
 845   1          unsigned char tmp[2];
 846   1      
 847   1          dmp_time = time / (1000 / DMP_SAMPLE_RATE);
 848   1          tmp[0] = (unsigned char)(dmp_time >> 8);
 849   1          tmp[1] = (unsigned char)(dmp_time & 0xFF);
 850   1          return mpu_write_mem(D_1_218, 2, tmp);
 851   1      }
 852          
 853          /**
 854           *  @brief      Set shake rejection threshold.
 855           *  If the DMP detects a gyro sample larger than @e thresh, taps are rejected.
 856           *  @param[in]  sf      Gyro scale factor.
 857           *  @param[in]  thresh  Gyro threshold in dps.
 858           *  @return     0 if successful.
 859           */
 860          int dmp_set_shake_reject_thresh(long sf, unsigned short thresh)
 861          {
 862   1          unsigned char tmp[4];
 863   1          long thresh_scaled = sf / 1000 * thresh;
 864   1          tmp[0] = (unsigned char)(((long)thresh_scaled >> 24) & 0xFF);
 865   1          tmp[1] = (unsigned char)(((long)thresh_scaled >> 16) & 0xFF);
 866   1          tmp[2] = (unsigned char)(((long)thresh_scaled >> 8) & 0xFF);
 867   1          tmp[3] = (unsigned char)((long)thresh_scaled & 0xFF);
 868   1          return mpu_write_mem(D_1_92, 4, tmp);
 869   1      }
 870          
 871          /**
 872           *  @brief      Set shake rejection time.
 873           *  Sets the length of time that the gyro must be outside of the threshold set
 874           *  by @e gyro_set_shake_reject_thresh before taps are rejected. A mandatory
 875           *  60 ms is added to this parameter.
 876           *  @param[in]  time    Time in milliseconds.
 877           *  @return     0 if successful.
 878           */
 879          int dmp_set_shake_reject_time(unsigned short time)
 880          {
 881   1          unsigned char tmp[2];
 882   1      
 883   1          time /= (1000 / DMP_SAMPLE_RATE);
 884   1          tmp[0] = time >> 8;
 885   1          tmp[1] = time & 0xFF;
 886   1          return mpu_write_mem(D_1_90,2,tmp);
 887   1      }
 888          
 889          /**
 890           *  @brief      Set shake rejection timeout.
 891           *  Sets the length of time after a shake rejection that the gyro must stay
 892           *  inside of the threshold before taps can be detected again. A mandatory
 893           *  60 ms is added to this parameter.
 894           *  @param[in]  time    Time in milliseconds.
 895           *  @return     0 if successful.
 896           */
 897          int dmp_set_shake_reject_timeout(unsigned short time)
 898          {
 899   1          unsigned char tmp[2];
 900   1      
 901   1          time /= (1000 / DMP_SAMPLE_RATE);
 902   1          tmp[0] = time >> 8;
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 16  

 903   1          tmp[1] = time & 0xFF;
 904   1          return mpu_write_mem(D_1_88,2,tmp);
 905   1      }
 906          
 907          /**
 908           *  @brief      Get current step count.
 909           *  @param[out] count   Number of steps detected.
 910           *  @return     0 if successful.
 911           */
 912          int dmp_get_pedometer_step_count(unsigned long *count)
 913          {
 914   1          unsigned char tmp[4];
 915   1          if (!count)
 916   1              return -1;
 917   1      
 918   1          if (mpu_read_mem(D_PEDSTD_STEPCTR, 4, tmp))
 919   1              return -1;
 920   1      
 921   1          count[0] = ((unsigned long)tmp[0] << 24) | ((unsigned long)tmp[1] << 16) |
 922   1              ((unsigned long)tmp[2] << 8) | tmp[3];
 923   1          return 0;
 924   1      }
 925          
 926          /**
 927           *  @brief      Overwrite current step count.
 928           *  WARNING: This function writes to DMP memory and could potentially encounter
 929           *  a race condition if called while the pedometer is enabled.
 930           *  @param[in]  count   New step count.
 931           *  @return     0 if successful.
 932           */
 933          int dmp_set_pedometer_step_count(unsigned long count)
 934          {
 935   1          unsigned char tmp[4];
 936   1      
 937   1          tmp[0] = (unsigned char)((count >> 24) & 0xFF);
 938   1          tmp[1] = (unsigned char)((count >> 16) & 0xFF);
 939   1          tmp[2] = (unsigned char)((count >> 8) & 0xFF);
 940   1          tmp[3] = (unsigned char)(count & 0xFF);
 941   1          return mpu_write_mem(D_PEDSTD_STEPCTR, 4, tmp);
 942   1      }
 943          
 944          /**
 945           *  @brief      Get duration of walking time.
 946           *  @param[in]  time    Walk time in milliseconds.
 947           *  @return     0 if successful.
 948           */
 949          int dmp_get_pedometer_walk_time(unsigned long *time)
 950          {
 951   1          unsigned char tmp[4];
 952   1          if (!time)
 953   1              return -1;
 954   1      
 955   1          if (mpu_read_mem(D_PEDSTD_TIMECTR, 4, tmp))
 956   1              return -1;
 957   1      
 958   1          time[0] = (((unsigned long)tmp[0] << 24) | ((unsigned long)tmp[1] << 16) |
 959   1              ((unsigned long)tmp[2] << 8) | tmp[3]) * 20;
 960   1          return 0;
 961   1      }
 962          
 963          /**
 964           *  @brief      Overwrite current walk time.
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 17  

 965           *  WARNING: This function writes to DMP memory and could potentially encounter
 966           *  a race condition if called while the pedometer is enabled.
 967           *  @param[in]  time    New walk time in milliseconds.
 968           */
 969          int dmp_set_pedometer_walk_time(unsigned long time)
 970          {
 971   1          unsigned char tmp[4];
 972   1      
 973   1          time /= 20;
 974   1      
 975   1          tmp[0] = (unsigned char)((time >> 24) & 0xFF);
 976   1          tmp[1] = (unsigned char)((time >> 16) & 0xFF);
 977   1          tmp[2] = (unsigned char)((time >> 8) & 0xFF);
 978   1          tmp[3] = (unsigned char)(time & 0xFF);
 979   1          return mpu_write_mem(D_PEDSTD_TIMECTR, 4, tmp);
 980   1      }
 981          
 982          /**
 983           *  @brief      Enable DMP features.
 984           *  The following \#define's are used in the input mask:
 985           *  \n DMP_FEATURE_TAP
 986           *  \n DMP_FEATURE_ANDROID_ORIENT
 987           *  \n DMP_FEATURE_LP_QUAT
 988           *  \n DMP_FEATURE_6X_LP_QUAT
 989           *  \n DMP_FEATURE_GYRO_CAL
 990           *  \n DMP_FEATURE_SEND_RAW_ACCEL
 991           *  \n DMP_FEATURE_SEND_RAW_GYRO
 992           *  \n NOTE: DMP_FEATURE_LP_QUAT and DMP_FEATURE_6X_LP_QUAT are mutually
 993           *  exclusive.
 994           *  \n NOTE: DMP_FEATURE_SEND_RAW_GYRO and DMP_FEATURE_SEND_CAL_GYRO are also
 995           *  mutually exclusive.
 996           *  @param[in]  mask    Mask of features to enable.
 997           *  @return     0 if successful.
 998           */
 999          int dmp_enable_feature(unsigned short mask)
1000          {
1001   1          unsigned char tmp[10];
1002   1      
1003   1          /* TODO: All of these settings can probably be integrated into the default
1004   1           * DMP image.
1005   1           */
1006   1          /* Set integration scale factor. */
1007   1          tmp[0] = (unsigned char)((GYRO_SF >> 24) & 0xFF);
*** ERROR C141 IN LINE 1007 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
*** ERROR C202 IN LINE 1007 OF DMP\inv_mpu_dmp_motion_driver.c: 'L': undefined identifier
*** ERROR C141 IN LINE 1007 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1007 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1007 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
1008   1          tmp[1] = (unsigned char)((GYRO_SF >> 16) & 0xFF);
*** ERROR C141 IN LINE 1008 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
*** ERROR C141 IN LINE 1008 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1008 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1008 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
1009   1          tmp[2] = (unsigned char)((GYRO_SF >> 8) & 0xFF);
*** ERROR C141 IN LINE 1009 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
*** ERROR C141 IN LINE 1009 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1009 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1009 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
1010   1          tmp[3] = (unsigned char)(GYRO_SF & 0xFF);
*** ERROR C141 IN LINE 1010 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
*** ERROR C141 IN LINE 1010 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
*** ERROR C141 IN LINE 1010 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near ')'
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 18  

1011   1          mpu_write_mem(D_0_104, 4, tmp);
1012   1      
1013   1          /* Send sensor data to the FIFO. */
1014   1          tmp[0] = 0xA3;
1015   1          if (mask & DMP_FEATURE_SEND_RAW_ACCEL) {
1016   2              tmp[1] = 0xC0;
1017   2              tmp[2] = 0xC8;
1018   2              tmp[3] = 0xC2;
1019   2          } else {
1020   2              tmp[1] = 0xA3;
1021   2              tmp[2] = 0xA3;
1022   2              tmp[3] = 0xA3;
1023   2          }
1024   1          if (mask & DMP_FEATURE_SEND_ANY_GYRO) {
1025   2              tmp[4] = 0xC4;
1026   2              tmp[5] = 0xCC;
1027   2              tmp[6] = 0xC6;
1028   2          } else {
1029   2              tmp[4] = 0xA3;
1030   2              tmp[5] = 0xA3;
1031   2              tmp[6] = 0xA3;
1032   2          }
1033   1          tmp[7] = 0xA3;
1034   1          tmp[8] = 0xA3;
1035   1          tmp[9] = 0xA3;
1036   1          mpu_write_mem(CFG_15,10,tmp);
1037   1      
1038   1          /* Send gesture data to the FIFO. */
1039   1          if (mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
1040   1              tmp[0] = DINA20;
1041   1          else
1042   1              tmp[0] = 0xD8;
1043   1          mpu_write_mem(CFG_27,1,tmp);
1044   1      
1045   1          if (mask & DMP_FEATURE_GYRO_CAL)
1046   1              dmp_enable_gyro_cal(1);
1047   1          else
1048   1              dmp_enable_gyro_cal(0);
1049   1      
1050   1          if (mask & DMP_FEATURE_SEND_ANY_GYRO) {
1051   2              if (mask & DMP_FEATURE_SEND_CAL_GYRO) {
1052   3                  tmp[0] = 0xB2;
1053   3                  tmp[1] = 0x8B;
1054   3                  tmp[2] = 0xB6;
1055   3                  tmp[3] = 0x9B;
1056   3              } else {
1057   3                  tmp[0] = DINAC0;
1058   3                  tmp[1] = DINA80;
1059   3                  tmp[2] = DINAC2;
1060   3                  tmp[3] = DINA90;
1061   3              }
1062   2              mpu_write_mem(CFG_GYRO_RAW_DATA, 4, tmp);
1063   2          }
1064   1      
1065   1          if (mask & DMP_FEATURE_TAP) {
1066   2              /* Enable tap. */
1067   2              tmp[0] = 0xF8;
1068   2              mpu_write_mem(CFG_20, 1, tmp);
1069   2              dmp_set_tap_thresh(TAP_XYZ, 250);
1070   2              dmp_set_tap_axes(TAP_XYZ);
1071   2              dmp_set_tap_count(1);
1072   2              dmp_set_tap_time(100);
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 19  

1073   2              dmp_set_tap_time_multi(500);
1074   2      
1075   2              dmp_set_shake_reject_thresh(GYRO_SF, 200);
*** ERROR C141 IN LINE 1075 OF DMP\inv_mpu_dmp_motion_driver.c: syntax error near 'L'
1076   2              dmp_set_shake_reject_time(40);
1077   2              dmp_set_shake_reject_timeout(10);
1078   2          } else {
1079   2              tmp[0] = 0xD8;
1080   2              mpu_write_mem(CFG_20, 1, tmp);
1081   2          }
1082   1      
1083   1          if (mask & DMP_FEATURE_ANDROID_ORIENT) {
1084   2              tmp[0] = 0xD9;
1085   2          } else
1086   1              tmp[0] = 0xD8;
1087   1          mpu_write_mem(CFG_ANDROID_ORIENT_INT, 1, tmp);
1088   1      
1089   1          if (mask & DMP_FEATURE_LP_QUAT)
1090   1              dmp_enable_lp_quat(1);
1091   1          else
1092   1              dmp_enable_lp_quat(0);
1093   1      
1094   1          if (mask & DMP_FEATURE_6X_LP_QUAT)
1095   1              dmp_enable_6x_lp_quat(1);
1096   1          else
1097   1              dmp_enable_6x_lp_quat(0);
1098   1      
1099   1          /* Pedometer is always enabled. */
1100   1          dmp.feature_mask = mask | DMP_FEATURE_PEDOMETER;
1101   1          mpu_reset_fifo();
1102   1      
1103   1          dmp.packet_length = 0;
1104   1          if (mask & DMP_FEATURE_SEND_RAW_ACCEL)
1105   1              dmp.packet_length += 6;
1106   1          if (mask & DMP_FEATURE_SEND_ANY_GYRO)
1107   1              dmp.packet_length += 6;
1108   1          if (mask & (DMP_FEATURE_LP_QUAT | DMP_FEATURE_6X_LP_QUAT))
1109   1              dmp.packet_length += 16;
1110   1          if (mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
1111   1              dmp.packet_length += 4;
1112   1      
1113   1          return 0;
1114   1      }
1115          
1116          /**
1117           *  @brief      Get list of currently enabled DMP features.
1118           *  @param[out] Mask of enabled features.
1119           *  @return     0 if successful.
1120           */
1121          int dmp_get_enabled_features(unsigned short *mask)
1122          {
1123   1          mask[0] = dmp.feature_mask;
1124   1          return 0;
1125   1      }
1126          
1127          /**
1128           *  @brief      Calibrate the gyro data in the DMP.
1129           *  After eight seconds of no motion, the DMP will compute gyro biases and
1130           *  subtract them from the quaternion output. If @e dmp_enable_feature is
1131           *  called with @e DMP_FEATURE_SEND_CAL_GYRO, the biases will also be
1132           *  subtracted from the gyro output.
1133           *  @param[in]  enable  1 to enable gyro calibration.
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 20  

1134           *  @return     0 if successful.
1135           */
1136          int dmp_enable_gyro_cal(unsigned char enable)
1137          {
1138   1          if (enable) {
1139   2              unsigned char regs[9] = {0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35, 0x5d};
1140   2              return mpu_write_mem(CFG_MOTION_BIAS, 9, regs);
1141   2          } else {
1142   2              unsigned char regs[9] = {0xb8, 0xaa, 0xaa, 0xaa, 0xb0, 0x88, 0xc3, 0xc5, 0xc7};
1143   2              return mpu_write_mem(CFG_MOTION_BIAS, 9, regs);
1144   2          }
1145   1      }
1146          
1147          /**
1148           *  @brief      Generate 3-axis quaternions from the DMP.
1149           *  In this driver, the 3-axis and 6-axis DMP quaternion features are mutually
1150           *  exclusive.
1151           *  @param[in]  enable  1 to enable 3-axis quaternion.
1152           *  @return     0 if successful.
1153           */
1154          int dmp_enable_lp_quat(unsigned char enable)
1155          {
1156   1          unsigned char regs[4];
1157   1          if (enable) {
1158   2              regs[0] = DINBC0;
1159   2              regs[1] = DINBC2;
1160   2              regs[2] = DINBC4;
1161   2              regs[3] = DINBC6;
1162   2          }
1163   1          else
1164   1              memset(regs, 0x8B, 4);
1165   1      
1166   1          mpu_write_mem(CFG_LP_QUAT, 4, regs);
1167   1      
1168   1          return mpu_reset_fifo();
1169   1      }
1170          
1171          /**
1172           *  @brief       Generate 6-axis quaternions from the DMP.
1173           *  In this driver, the 3-axis and 6-axis DMP quaternion features are mutually
1174           *  exclusive.
1175           *  @param[in]   enable  1 to enable 6-axis quaternion.
1176           *  @return      0 if successful.
1177           */
1178          int dmp_enable_6x_lp_quat(unsigned char enable)
1179          {
1180   1          unsigned char regs[4];
1181   1          if (enable) {
1182   2              regs[0] = DINA20;
1183   2              regs[1] = DINA28;
1184   2              regs[2] = DINA30;
1185   2              regs[3] = DINA38;
1186   2          } else
1187   1              memset(regs, 0xA3, 4);
1188   1      
1189   1          mpu_write_mem(CFG_8, 4, regs);
1190   1      
1191   1          return mpu_reset_fifo();
1192   1      }
1193          
1194          /**
1195           *  @brief      Decode the four-byte gesture data and execute any callbacks.
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 21  

1196           *  @param[in]  gesture Gesture data from DMP packet.
1197           *  @return     0 if successful.
1198           */
1199          static int decode_gesture(unsigned char *gesture)
1200          {
1201   1          unsigned char tap, android_orient;
1202   1      
1203   1          android_orient = gesture[3] & 0xC0;
1204   1          tap = 0x3F & gesture[3];
1205   1      
1206   1          if (gesture[1] & INT_SRC_TAP) {
1207   2              unsigned char direction, count;
1208   2              direction = tap >> 3;
1209   2              count = (tap % 8) + 1;
1210   2              if (dmp.tap_cb)
1211   2                  dmp.tap_cb(direction, count);
1212   2          }
1213   1      
1214   1          if (gesture[1] & INT_SRC_ANDROID_ORIENT) {
1215   2              if (dmp.android_orient_cb)
1216   2                  dmp.android_orient_cb(android_orient >> 6);
1217   2          }
1218   1      
1219   1          return 0;
1220   1      }
1221          
1222          /**
1223           *  @brief      Specify when a DMP interrupt should occur.
1224           *  A DMP interrupt can be configured to trigger on either of the two
1225           *  conditions below:
1226           *  \n a. One FIFO period has elapsed (set by @e mpu_set_sample_rate).
1227           *  \n b. A tap event has been detected.
1228           *  @param[in]  mode    DMP_INT_GESTURE or DMP_INT_CONTINUOUS.
1229           *  @return     0 if successful.
1230           */
1231          int dmp_set_interrupt_mode(unsigned char mode)
1232          {
1233   1          const unsigned char regs_continuous[11] =
1234   1              {0xd8, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0x09, 0xb4, 0xd9};
1235   1          const unsigned char regs_gesture[11] =
1236   1              {0xda, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0xda, 0xb4, 0xda};
1237   1      
1238   1          switch (mode) {
1239   2          case DMP_INT_CONTINUOUS:
1240   2              return mpu_write_mem(CFG_FIFO_ON_EVENT, 11,
1241   2                  (unsigned char*)regs_continuous);
1242   2          case DMP_INT_GESTURE:
1243   2              return mpu_write_mem(CFG_FIFO_ON_EVENT, 11,
1244   2                  (unsigned char*)regs_gesture);
1245   2          default:
1246   2              return -1;
1247   2          }
1248   1      }
1249          
1250          /**
1251           *  @brief      Get one packet from the FIFO.
1252           *  If @e sensors does not contain a particular sensor, disregard the data
1253           *  returned to that pointer.
1254           *  \n @e sensors can contain a combination of the following flags:
1255           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
1256           *  \n INV_XYZ_GYRO
1257           *  \n INV_XYZ_ACCEL
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 22  

1258           *  \n INV_WXYZ_QUAT
1259           *  \n If the FIFO has no new data, @e sensors will be zero.
1260           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
1261           *  return a non-zero error code.
1262           *  @param[out] gyro        Gyro data in hardware units.
1263           *  @param[out] accel       Accel data in hardware units.
1264           *  @param[out] quat        3-axis quaternion data in hardware units.
1265           *  @param[out] timestamp   Timestamp in milliseconds.
1266           *  @param[out] sensors     Mask of sensors read from FIFO.
1267           *  @param[out] more        Number of remaining packets.
1268           *  @return     0 if successful.
1269           */
1270          int dmp_read_fifo(short *gyro, short *accel, long *quat,
1271              unsigned long *timestamp, short *sensors, unsigned char *more)
1272          {
1273   1          unsigned char fifo_data[MAX_PACKET_LENGTH];
1274   1          unsigned char ii = 0;
1275   1      
1276   1          /* TODO: sensors[0] only changes when dmp_enable_feature is called. We can
1277   1           * cache this value and save some cycles.
1278   1           */
1279   1          sensors[0] = 0;
1280   1      
1281   1          /* Get a packet. */
1282   1          if (mpu_read_fifo_stream(dmp.packet_length, fifo_data, more))
1283   1              return -1;
1284   1      
1285   1          /* Parse DMP packet. */
1286   1          if (dmp.feature_mask & (DMP_FEATURE_LP_QUAT | DMP_FEATURE_6X_LP_QUAT)) {
1287   2      #ifdef FIFO_CORRUPTION_CHECK
1288   2              long quat_q14[4], quat_mag_sq;
1289   2      #endif
1290   2              quat[0] = ((long)fifo_data[0] << 24) | ((long)fifo_data[1] << 16) |
1291   2                  ((long)fifo_data[2] << 8) | fifo_data[3];
1292   2              quat[1] = ((long)fifo_data[4] << 24) | ((long)fifo_data[5] << 16) |
1293   2                  ((long)fifo_data[6] << 8) | fifo_data[7];
1294   2              quat[2] = ((long)fifo_data[8] << 24) | ((long)fifo_data[9] << 16) |
1295   2                  ((long)fifo_data[10] << 8) | fifo_data[11];
1296   2              quat[3] = ((long)fifo_data[12] << 24) | ((long)fifo_data[13] << 16) |
1297   2                  ((long)fifo_data[14] << 8) | fifo_data[15];
1298   2              ii += 16;
1299   2      #ifdef FIFO_CORRUPTION_CHECK
1300   2              /* We can detect a corrupted FIFO by monitoring the quaternion data and
1301   2               * ensuring that the magnitude is always normalized to one. This
1302   2               * shouldn't happen in normal operation, but if an I2C error occurs,
1303   2               * the FIFO reads might become misaligned.
1304   2               *
1305   2               * Let's start by scaling down the quaternion data to avoid long long
1306   2               * math.
1307   2               */
1308   2              quat_q14[0] = quat[0] >> 16;
1309   2              quat_q14[1] = quat[1] >> 16;
1310   2              quat_q14[2] = quat[2] >> 16;
1311   2              quat_q14[3] = quat[3] >> 16;
1312   2              quat_mag_sq = quat_q14[0] * quat_q14[0] + quat_q14[1] * quat_q14[1] +
1313   2                  quat_q14[2] * quat_q14[2] + quat_q14[3] * quat_q14[3];
1314   2              if ((quat_mag_sq < QUAT_MAG_SQ_MIN) ||
1315   2                  (quat_mag_sq > QUAT_MAG_SQ_MAX)) {
1316   3                  /* Quaternion is outside of the acceptable threshold. */
1317   3                  mpu_reset_fifo();
1318   3                  sensors[0] = 0;
1319   3                  return -1;
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 23  

1320   3              }
1321   2              sensors[0] |= INV_WXYZ_QUAT;
1322   2      #endif
1323   2          }
1324   1      
1325   1          if (dmp.feature_mask & DMP_FEATURE_SEND_RAW_ACCEL) {
1326   2              accel[0] = ((short)fifo_data[ii+0] << 8) | fifo_data[ii+1];
1327   2              accel[1] = ((short)fifo_data[ii+2] << 8) | fifo_data[ii+3];
1328   2              accel[2] = ((short)fifo_data[ii+4] << 8) | fifo_data[ii+5];
1329   2              ii += 6;
1330   2              sensors[0] |= INV_XYZ_ACCEL;
1331   2          }
1332   1      
1333   1          if (dmp.feature_mask & DMP_FEATURE_SEND_ANY_GYRO) {
1334   2              gyro[0] = ((short)fifo_data[ii+0] << 8) | fifo_data[ii+1];
1335   2              gyro[1] = ((short)fifo_data[ii+2] << 8) | fifo_data[ii+3];
1336   2              gyro[2] = ((short)fifo_data[ii+4] << 8) | fifo_data[ii+5];
1337   2              ii += 6;
1338   2              sensors[0] |= INV_XYZ_GYRO;
1339   2          }
1340   1      
1341   1          /* Gesture data is at the end of the DMP packet. Parse it and call
1342   1           * the gesture callbacks (if registered).
1343   1           */
1344   1          if (dmp.feature_mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
1345   1              decode_gesture(fifo_data + ii);
1346   1      
1347   1          get_ms(timestamp);
1348   1          return 0;
1349   1      }
1350          
1351          /**
1352           *  @brief      Register a function to be executed on a tap event.
1353           *  The tap direction is represented by one of the following:
1354           *  \n TAP_X_UP
1355           *  \n TAP_X_DOWN
1356           *  \n TAP_Y_UP
1357           *  \n TAP_Y_DOWN
1358           *  \n TAP_Z_UP
1359           *  \n TAP_Z_DOWN
1360           *  @param[in]  func    Callback function.
1361           *  @return     0 if successful.
1362           */
1363          int dmp_register_tap_cb(void (*func)(unsigned char, unsigned char))
1364          {
1365   1          dmp.tap_cb = func;
1366   1          return 0;
1367   1      }
1368          
1369          /**
1370           *  @brief      Register a function to be executed on a android orientation event.
1371           *  @param[in]  func    Callback function.
1372           *  @return     0 if successful.
1373           */
1374          int dmp_register_android_orient_cb(void (*func)(unsigned char))
1375          {
1376   1          dmp.android_orient_cb = func;
1377   1          return 0;
1378   1      }
1379          
1380          /**
1381           *  @}
C51 COMPILER V9.57.0.0   INV_MPU_DMP_MOTION_DRIVER                                         07/20/2020 01:26:07 PAGE 24  

1382           */
1383          

C51 COMPILATION COMPLETE.  1 WARNING(S),  35 ERROR(S)
